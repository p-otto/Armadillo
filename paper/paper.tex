\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\input{solidity-highlighting.tex}

\lstset{basicstyle=\small\ttfamily}

\begin{document}
%
\title{Untrusted B2B Collaboration using the Blockchain}
%
%
\author{Jonas Beyer \and Philipp Otto \and S\"oren Tietb\"ohl}
%
\authorrunning{J. Beyer et al.}
%
\institute{
	Hasso-Plattner-Institut, Potsdam, Germany\\
	\email{\{jonas.beyer,philipp.otto2,soeren.tietboehl\}@student.hpi.de}}
%
\maketitle % typeset the header of the contribution
%
\begin{abstract}
	Lack of trust between communication partners is one of the major issues companies face when implementing business processes in a cross-organizational setting.
	Blockchain is an emerging technology that enables decentralization and distribution of state without the need for a trusted central instance.
	As a result, it is possible to form consensus in the communication between otherwise untrusting parties.
	In this paper we introduce Armadillo, an open-source prototype implementation for realizing business process choreographies using the Ethereum blockchain.
	We present a user interface for connecting business processes with blockchain calls, as well as an underlying smart contract structure for inter-process communication.

	\keywords{Business Processes \and BPMN \and Choreographies \and Blockchain \and Ethereum \and Smart Contracts}
\end{abstract}
%
%
%
% TODO casing of headlines (capital)
\section{Introduction}
% TODO: rewrite introduction

% Establish common ground with reader Worth readers time? Give some results

% Write it once at the start, then rewrite at the end
% use it to guide paper

% Important -> this structure will be expected

% Context (Topic / Terminology)
% Problem & Relevance (Problem - Costs / Current state - Gain)
% Related Work (Existing solutions / Shortcomings)
% Goals / Claims (Contribution, Sketch Results)
% Paper structure (The remainder of this paper is structured as follows ...)

% What is BPMN?
The Business Process Model Notation (BPMN) enables detailed documentation of business processes. This is used to realize complex inter-business processes which involve vast communication structures. One common problem is that within these processes the parties have to trust each other.
% What is Blockchain?

With the increasing spread of Blockchain technology, this problem could be rectified.
A Blockchain is a decentralized information-storage network. Information is stored in blocks, which are chained together via cryptograhic means. This means, that many participants can agree on a common public state of information without trusting each other. This technology is commonly used to realize virtual currencies, also called cryptocurrencies.
Ethereum \cite{wood2014ethereum} is one implementation of the Blockchain concept, and it realizes a key feature called smart contracts.
Smart contracts are small programs, which are ran by the Blockchain network. They have very limited processing power, but they enable the execution of code which has a commonly known state.

%What problems are there with BPMN that can be solved with Blockchain?
The problem of needing to trust each other when collaborating in a business process can be addressed by applying the benefits of blockchain technology. The Blockchain be used in several ways to facilitate trusted communication between untrusted parties.

% What approaches exist currently (Caterpillar \cite{lopez2017caterpillar}, Untrusted paper \cite{weber2016untrusted})
Current approaches aim to convert the functionality of traditional BPMN Engines to smart contracts on the Ethereum Blockchain.

Caterpillar~\cite{lopez2017caterpillar} features the implementation of most common BPMN elements. It enables the transformation of BPMN Models to smart contracts, which can be deployed and executed on the Blockchain.

% TODO write more here
Weber et al.~\cite{weber2016untrusted} realize Orchestrations on the Blockchain.

%What is our general Idea?
We want to expand on the work of Weber et al. and implement true choreographies. In their current approach they are using one central smart contract called a mediator / monitor which manages the Orchestration state.
We will have a set of smart contracts for every party, which will then communicate with each other to realize the choreography.
%What are our results? (briefly)

The rest of this paper is structured as follows: In Section 2 we will discuss concepts and technologies required for our work.
In Section 3 we will present our use case and our solution concept.
Section 4 presents our implementation and tools.
In Section 5 we evaluate our solution.
Finally, Section 6 will present future work and Section 7 will conclude the paper.

% TODO include example here (collab model from weber paper)
\section{Preliminary}
In the following section we present concepts and technologies that are related to our work.

\subsection{Orchestrations and Choreographies}

% TODO improve wording
% TODO reference Weskes book or smth
Buisiness Processes with multiple participants are modeled using collaboration models, an example can be seen in Figure X. % TODO reference example here
These collaboration models can be implemented in two variants: As orchestrations, or as choreographies.
Orchestrations view the Process from a central perspective, most commonly either the central pool which the collaboration focuses on, or the process initiator.
The main pool inhibits the role of a mediator or manager, dictating and guiding the execution.
Thus the process has a clear, well-defined order in which tasks have to be executed.
This also means, that the process always has a clear state of execution.

In a choreography, the participants are much more independent. 
Each participant is its own seperate entity in the implemenation, leading to asynchronous execution and communication.
Thus, there is also no clear order or state, because the participants are acting and communicating independent of others.

One of the main ways our solution differs from the solution of Weber et al.~\cite{weber2016untrusted} is in the way we implement collaboration models.
Weber et al. implement choreographies by means of a central mediator/monitor contract, where every step in the process is managed by this central contract.
The contract also holds an internal state of the process.
As explained above, this means they realize the collaboration model with an orchestration.
Thus, our goal was to implement the collaboration models as choreographies.
Therefore we developed a solution, which models each pool seperately as their own entity, including having their own contracts.
This decreases the amount of trust needed between the communication partners.
By giving every pool their own set of contracts, we can make sure that every pool has control over the part of the process that is most relevant to them.

% TODO write about public and private processes

\subsection{Blockchain}
A blockchain is a distributed ledger that allows users to find a concensus in decentralized applications.
It works by splitting information into blocks that are connected as a linked list.
%TODO proof of work is only one possibility
%TODO explain more in depth?
Each block has to be signed in a way that is mathematically hard to calculate, but easy to verify.
Therefore users can verify if their local blockchain is valid.
If the same block is signed at the same time, a fork of the blockchain can happen, i.e. two versions of the same blockchain exist at the same time.
A concensus is reached by propagating the longest blockchain within the network until it is accepted by all parties of the network.

%TODO reference original blockchain paper
Blockchain technology is used in cryptocurrencies, most notably Bitcoin \cite{nakamoto2008bitcoin}.
The use in cryptocurrency has laid the foundation for a number of decentralized application besides financial ones.
Ethereum \cite{wood2014ethereum} is a cryptocurrency that also builds on blockchain technologies and allows users to execute code in the form of \emph{smart contracts}.
Smart contracts are Turing complete code artifacts, that can be deployed on the blockchain and have an interface that is callable by users.
They can receive and send money, store information locally and emit events on the blockchain ledger.
These events contain pieces of information that are permanently stored publicly on the blockchain.
External programs can watch, and react to, these events.
When calling functions on a smart contract, users have to supply \emph{gas}, a unit that powers smart contract computations.
Contracts deplete gas for each operation and return excess gas back to the user.
This ensures that contracts are not running for an unlimited amount of time and that computations on the blockchain are expensive in order to avoid unnecessary operations being performed on-chain.
Because of the gas limit and high price, the computational power of smart contracts is very limited.
Smart contracts can also not communicate with anything outside the blockchain.
%TODO short text on the paper which shows smart contract examples
%TODO short text on solidity

% TODO search for more papers, such as Optimized execution of business processes on blockchain
\subsection{Prior Work on Business Processes on the Blockchain}
In \cite{weber2016untrusted}, a first approach of monitoring and coordinating business process interactions across organizations on the blockchain was presented.
Using a smart contract as a central \emph{monitor} or \emph{mediator} of the communication, a form of inter-process orchestration is implemented.
They describe a contract architecture, where a factory contract is responsible for deploying instance contracts for each process instance.
They also introduce the concept of \emph{triggers}, applications that listen to events on the blockchain and trigger external API calls.
In order to achieve BPMN-to-Solidity compilation, they describe translation rules to transform BPMN elements to Solidity code.
%TODO highlight lack of access right explanation and problem of central contract?

%we build on:
%factories \& instances
%registering users to roles
%triggers
%the model they used (originally from Fdhila et al)

%we don\'t:
%do bpmn solidity translation
%use one central contract instance

%summarize Caterpillar
%acknowledge their Work
%display the shortcomings
\cite{lopez2017caterpillar} presents an open-source implementation of an Ethereum-based Business Process Management System.
It implements BPMN-to-Solidity compilation and thereby tracks the state of process executions on the blockchain.
Processes can be started and executed via a user interface, which calls the generated Solidity code in the background.

%describes components and architecture of engine
%automatic bpmn solidity translation
%no choreographies / lanes supported, all tasks / transitions are managed on-chain through process %contract

\section{Solution approach}
We propose a system design, that allows choreographies to be executed publicly on the blockchain.
In the following section, we describe our approach and its architecture.

\section{Requirements}
% refer to presentation here
% TODO Vielleicht könnt ihr ganz am Anfang einen Überblick geben was das System erfüllen muss, wie das geschieht erklärt ihr dann in den  Unterkapiteln

\subsection{System overview}
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{fig/system_diagram.eps}
	\caption{An architecture diagram showing the interactions within the system.}
	\label{fig:system_diagram}
\end{figure}

Every organization provides an interface of their public process in an \emph{instance contract}.
Additionally, \emph{factory contracts} manage these instance contracts and \emph{access contracts} are used for rights management.
The contract structure will be described in detail in the following sections.
We assume that all participating organizations use a process engine to execute their private processes.
When a throw event is triggered within a process engine, the process engine calls the \emph{throw event function} on an instance contract and the corresponding \emph{catch event function} is called on the instance contract of the organization responsible for catching the event.
Thus, all communication between organizations is recorded on the blockchain.

%TODO reference "trigger" from Untrusted paper
Each organization uses a \emph{trigger} that continuously listens to catch events.
If a catch event is observed, this information is relayed to the process engine to handle the event.
The usage of the blockchain to monitor the choreography is encapsulated in the process engine and is therefore hidden from the users.

The structure of components for one organization can be seen in Figure \ref{fig:system_diagram}.

\subsection{Contract Structure}
To realize the system, we use three kinds of smart contracts.
Firstly, each organization uses one \emph{instance contract} per process instance.
It represents the public process of the organization for the corresponding process.
It is called during the process execution when a catch or throw event is reached in the process instance.
When this happens, it emits an event on the blockchain to document this fact.

Secondly, each organization uses one \emph{factory contract} per process.
It is responsible for creating instance contracts and saving a mapping from instance IDs to the corresponding contracts.

Thirdly, each organization uses \emph{access contracts} to manage which users can trigger events on the instance contracts.
Either there is one access contract per process or access contracts are shared over multiple processes depending on the use case.

\subsection{Per company setup}
\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/initialization.eps}
	\caption{A sequence diagram describing the initialization process for an organization.}
	\label{fig:initialization}
\end{figure}

%TODO add a step where other factory contracts are set
Each organization needs to perform some setup before they can take part in a process execution.
An access contract and a factory contract for a process need to be deployed, if it has not been done yet.
Additionally, the user-to-role and and task-to-role mappings have to be updated, to allow verification of users during the process execution.
A diagram of this process can be seen in Figure \ref{fig:initialization}.

\subsection{Interaction setup}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{fig/instance_creation.eps}
	\caption{A sequence diagram describing the process of creating a new process instance.}
	\label{fig:instance_creation}
\end{figure}

In order to create a new process instance, the organization that initiates the instance by triggering the first throw event has to explicitly create an instance contract by calling the factory contract.
To create an instance contract, the factory contract may need to initialize other instance contracts by calling other factory contracts.
When all partner instance, factory and access contracts are known, the instance contract can be created and its address is returned to the user and an event is emitted to the blockchain.
This process is visualized in Figure \ref{fig:instance_creation}.

The recursive initialization ensures that all instance contracts that are part of the process instance will be created by one function call.
%TODO add emit event in the diagram
%TODO better formulation
The organizations that did not start the instance creation can detect the new process instance by using their trigger to watch the factory contract.

\subsection{Sending messages}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{fig/event_sending.eps}
	\caption{A sequence diagram describing the process of sending a message to a collaboration partner.}
	\label{fig:event_sending}
\end{figure}

%TODO correctly show that the address is passed instead of using msg.sender
When a throw event is triggered in the process engine of organization $A$, the process engine of $A$ calls the corresponding \emph{throw event function} on the instance contract of organization $A$.
In the instance contract of $A$ an authorization is performed by looking up the sender address in the access contract of $A$.
If this check is successful, the \emph{catch event function} is called on the partner instance contract of $B$.
In the instance contract of $B$ there is another authorization against the access contract of $A$.
This ensures that both sides can be confident, that the throw event was triggered by an authorized person who belongs to organization $A$.
If this check was also successful, an event is emitted to the blockchain.
This will be detected by the trigger of $B$ and passed to the process engine.
Thus, a message was sent from $A$ to $B$ via the blockchain and an audit trail was created.
An example can be seen in the sequence diagram in Figure \ref{fig:event_sending}.


\section{Implementation}

Given the architecture, we will now discuss the implementation of the contracts used in the system.
Afterwards, we will shortly describe the tools we built for interacting with the system.

\subsection{Contracts}

In the following, we will formally describe our contract implementations.
The implemented contracts can be found in our repository at \url{https://github.com/p-otto/ProcessesMeetBlockchain2018/tree/master/armadillo/resources}.
% TODO repo ist noch private
% TODO update if repository changes

\subsubsection{Process Contracts}

For taking part in the process collaboration, each company needs to deploy a factory contract that is responsible for creating instance contracts.
To this end, the factory contract source code needs to contain the definition of the company's instance contract.
This closely follows the factory contract pattern used in \cite{weber2016untrusted}, and described as Pattern 14 in \cite{xu2018pattern}.

In our implementation, a company's factory contract also knows the address of the company's access contract for convenience.
Additionally, it stores the addresses of created instances, mapped by a \textit{choreography instance ID}, i.e., an ID that is shared between all choreography participants for each instance of the shared choreography.

To allow interaction between companies via the blockchain, two participants need to exchange the addresses of their factory contracts when there is a direct interaction between them.

A factory contract thus has the resulting interface:
\begin{itemize}
	\item A \texttt{constructor} where the address of the company's access contract is passed
	\item Setter methods for the factory contract addresses of interaction partners
	\item A \texttt{createInstance} function
	\item A \texttt{getAccessAddress} function
	\item A \texttt{isInstance} function, checking if a given address belongs to an instance created by this factory, for a given choreography instance ID % TODO rephrase?
\end{itemize}

Internally, there are a few implementation details worth mentioning.
Regarding storage, private fields are necessary holding the factory contract addresses, the access contract address as well as the instance address mapping.
To avoid communication errors at runtime, it should not be possible to call \texttt{createInstance} before all required factory addresses are set.
Finally, there is one minor implementation difference depending on whether a participant is the \textit{choreography initiator} -- the participant to manually start the choreography instance by sending a request -- or instead is starting its instance as a response to another participant's request: % TODO arrgh bessere formulierung
The initiator needs to generate the choreography instance ID inside of its \texttt{createInstance} function, and pass it to all its interaction partners.
Every other participant needs to have a parameter for the ID in their \texttt{createInstance} function.

Communication between smart contracts happens in the form of function calls.
To allow the factory and instance contracts to call functions on their interaction partner's contracts, the partner's function interface needs to be known, i.e., it needs to be declared in the factory contract source code.
%- the access contract (same for every participant)
%- remote factory contracts (if receiving messages from remote, for verification)
%- remote instance contracts (if sending messages to remote instance)

The instance contract definition is also part of the factory contract source code.
The factory contract creates an instance by calling its constructor and passing all for the inter-process communication required addresses.
Instance contracts provide functions for each sending action, i.e., send tasks or events in the company's process, which can be called by the process engine.
For each receiving action (task or event), a function needs to be present that can be called from other instance contracts.
When company $A$ triggers a sending function on their instance contract, it in turn calls a corresponding receive function on the instance contract of company $B$.

Instance contracts need to store:
\begin{itemize}
	\item The choreography instance ID for verifying incoming messages
	\item The addresses of the factory and access contracts of partners for verifying incoming messages
	\item The addresses of the instance contracts of partners for sending messages
	\item The address of the company's own access contract, for verifying local function calls
	\item The address of the company's own factory contract, for returning any remaining funds upon \texttt{selfdestruct}
\end{itemize}

A few more implementation details are worth noting:
Verification is implemented on sender-side and on receiver side.
Each send function has a guard checking the caller in the company's own access contract.
Each receive function has a guard checking a) that the caller is a contract instance that is part of the choreography instance (via the partner factory contract), and b) checking the account behind the request in the partner's access contract.
Guarding functions against unwanted access was described in pattern 13, Embedded Permission, in \cite{xu2018pattern}.

Having achieved a traceable communication on the blockchain using contract function calls, we still want to access messages in off-chain applications, e.g., triggering process events in a process engine on message receive.
To this end, smart contracts need to implement events that are emitted to the blockchain whenever a receive function is executed.
Blockchain events can then be watched, and reacted upon, by off-chain components.

In our current implementation, the end of a process instance is marked by the instance contract selfdestructing.
At the end of the execution of the last send or receive function in the process, the solidity builtin \texttt{selfdestruct} is called.
By passing the factory contract address, potential remaining funds are transferred to the factory contract.

\subsubsection{Access Contract}

Each company deploys an access contract that holds information about the roles and permissions of the company's employees.
Having permission data encapsuled in a separate access contract follows pattern 12, the Data Contract pattern, from \cite{xu2018pattern}.
It allows decoupling the roles and permissions from the actual contract instances, allowing for a simple modification at runtime.
Access contracts can be deployed per process, or even once per company as a single source of truth for all processes.

To allow the administration of user permissions, access contracts provide the following interface:
\begin{itemize}
	\item \texttt{assignRoleToUser(userAddress, role)}
	\item \texttt{removeRoleFromUser(userAddress, role)}
	\item \texttt{assignTaskToRole(task, role)}
	\item \texttt{removeTaskFromRole(task, role)}
\end{itemize}
The access to these functions should be guarded, allowing only a specific administrator address to call them.

Verifying a users permission to execute a certain task can be achieved by calling \texttt{isAuthorized(userAddress, task)}.
\newline

Given this interface, there are multiple possible implementation approaches for access contracts.
As it was our main focus to develop a running prototype, and not to provide an optimized, production-ready system, we decided on a simple mapping-based implementation:
\begin{lstlisting}[
  caption=Mappings in our access contract implementation,
  language=Solidity
]
pragma solidity ^0.4.23;

contract Access {
    mapping(string => string) taskToRole;
    mapping(string => uint) roleToIndex;
    mapping(address => uint) addressToAccessBitmask;
    ...
}
\end{lstlisting}
The first mapping stores the tasks that can be executed by a specific role (cf. pools and lanes, and their contained tasks, in BPMN diagrams).
The second mapping assigns each role an index in the access bitmask, i.e., if the bit at the given index is set, the user holds the corresponding role.
The third mapping assigns such an access bitmask to each user.

Storing large amounts data on the blockchain is expensive by design.
As the mappings grow in size with each user, role and task that is part of some process in the company, our implementation is probably not suited for real-world application.
Finding optimized, less costly (both in computation cost and storage cost) approaches is part of future work.
One other approach we thought of is based on Pattern 5 of \cite{xu2018pattern} - depicting real world permissions as tokens, and "paying" with these tokens on function call to verify one's role.

\subsection{Tools}

In the following, we will briefly present the tools we implemented integrate process management with our blockchain approach.
The implementations can be found in our repository at \url{https://github.com/p-otto/ProcessesMeetBlockchain2018/}, in the \texttt{armadillo} and \texttt{eth\_admin} folders, respectively.
% TODO repo ist noch private
% TODO update if repository changes
% TODO overfull hbox

\subsubsection{Armadillo}

As a way of joining process execution with our blockchain architecture, we developed a single page web application in JavaScript and HTML, using the Vue.js framework\footnote{\url{https://vuejs.org}}.
With the help of the Web3 Ethereum JavaScript API\footnote{\label{web3}\url{https://github.com/ethereum/web3.js/}}, we can trigger contract functions based on user actions in the applications user interface.
Armadillo also implements the upload and rendering of BPMN diagrams using the bpmn.js toolkit\footnote{\url{https://bpmn.io/toolkit/bpmn-js/}}.
Building upon the BPMN viewer provided in the toolkit, we implemented the handling of user clicks on \textit{BPMN Service Tasks}, which allowed us to use the viewer as a process engine mock.
A screencast of the full choreography can be found in the respository under \url{https://github.com/p-otto/ProcessesMeetBlockchain2018/blob/master/presentation/armadillo-screencast.mp4}.
% TODO repo, hbox etc.

\subsubsection{Eth\_Admin}

We developed a small command line application for managing users and roles via the access contract.
The application is written in JavaScript in the node.js framework\footnote{\url{https://nodejs.org/}}.
Internally, calls functions on access contracts utilizing the Web3 Ethereum JavaScript API\textsuperscript{\ref{web3}}.
We decide to build the command line functionality with the help of the Vorpal framework\footnote{\url{http://vorpal.js.org/}}.
The README in our repository describes how to use the application.

\section{Evaluation}

When evaluating blockchain implementations, the underlying system comes with new aspects that need to be considered.
First, computation and data storage on the blockchain needs to be paid for in \textit{transaction fees}.
In Ethereum, the unit \textit{gas} was introduced as a way of having consistent fee pricing in spite of fluctuating Ether prices.

We measured the gas used for each transaction that is executed by the Armadillo tool, and we summed up the gas usage for the different kinds of contracts in the companies in the following table:

\begin{tabular}{l|l|l|l}
	% TODO
	a & b & c & d
\end{tabular}

Most of the transactions have proven to come with reasonable gas costs.
However, the instantiation cost that is currently paid by the initiator appears to be problematic.
As the first instantiation transitively triggers all the other participant's instantiations, this can become quite costly, and might even surpass the \textit{gas limit}, the maximum amount of gas that can be spent per transaction.
Even if that is not the case, a high gas cost is still a problem, since transactions with high gas costs are less likely to be included in a block by miners, possibly leading to long waiting times. % TODO explain?

Second, security is one of the main reasons to opt for blockchain systems.
In our case, we put effort into making the message exchange secure by adding multiple steps of access verification using the access contracts.
Access contracts themselves, however, only implement access verification by comparing the sender address with the address the contract was deployed with (the \textit{owner} address).
As the owner can give and remove access rights freely, another layer of off-chain security might make sense here to restrict the owner account from unwanted access.

%Time for one instance
%Setup difficulty

\section{Future Work}

We researched a system prototype for handling process choreographies on the blockchain.
While we were able to execute an example choreography using our implementation, a few aspects are left for future work.

\subsubsection{Instantiation Costs}

In the evaluation, we realized that the instantiation cost currently is too high for our system to be used in a productive environment.
Further research thus could be invested into a more decentralized instantiation, where each participant pays for its own instance contract creation.
One approach we discussed, but did not have the time to implement, would be to have the intiator emit a specific instance creation event that each other participant would listen to.
Then, a trigger could be implemented, that calls the \texttt{createInstance} method as soon as the event is received.

During evaluation, we saw that the instantiation costs are very high, have a potential to hit the gas limit in larger choreographies and also have to be paid by the initiator.
These problems need to be addressed before our solution is viable for production use.
One possbile way to distribute the costs among the participants makes use of triggers on the factory contracts.
Instead of creating all instance contracts transitively, the factory contract would have a method for accepting requests for instantiation.
The process engine could then react to such a call via a trigger, and call the instantiation method.
Then the other factory would have to be notified that the instantiation was successful.

\subsubsection{Access Contract}

As stated earlier, there possibly are better ways of implementing a role-based access control inside a smart contract.
We decided for a simple mapping-based approach, which requires a relatively large amount of memory.
Finding approaches that are more suited for blockchain architectures is one direction in which further research could go.

\subsubsection{Process Contract Generation}

Our contract implementations are the result of manual, iterative development.
Having reached the final iteration, we realized that most of the implementation could probably be generated, i.e., from a choreography diagram (or at least from the participant's public processes).
The next step would be to define a template for the factory contract source code, to determine which parts are easily generated, and which parts might need manual adjustments, e.g., depending on whether the participant is the initiator or not.
Given such a template, one could work on a contract generation tool that takes a diagram as input and produces factory contract code.

Currently all contracts are written manually.
Since the contracts all share the same patterns,  this is a prime candidate for automation.
A possible implementation could use a rule-based approach for translating the choreography model, similar to \cite{lopez2017caterpillar}.
This would then automatically generate Solidity code for the access and factory contracts.

\subsubsection{Process Engine Integration}

In related work \cite{lopez2017caterpillar}, process logic was executed on the blockchain.
As we decided for a hybrid approach, using a process engine for execution and the Ethereum blockchain for traceable message passing, we implemented a mock process engine in our application.
Now, it certainly makes sense to integrate the system with a productive process engine implementation, e.g., the Camunda BPMN Workflow Engine\footnote{\url{https://camunda.com/products/bpmn-engine}} for further evaluation.

\section{Conclusion}

In this paper, we presented a system architecture and prototypical implementation for connecting process execution with blockchain technology.
While keeping the process execution off-chain, we developed an approach of inter-process communication using the Ethereum blockchain as a messaging channel.
Having a permanent ledger as the underlying data structure storing messages, faults and misunderstandings can be traced back to their origin and responsibilities are disclosed.

Building on the findings of this paper, improvements regarding runtime and execution costs open up a wide area of possible future work on the topic.

Currently, blockchain technology is most widely used to handle monetary transactions.
Instead of shifting assets between partners, however, we are using the blockchain to shift \textit{responsibilities}.
Given the similar nature of the two, we speculate that this topic is of future relevance.
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{references}

\end{document}
