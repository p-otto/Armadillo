\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\input{solidity-highlighting.tex}

\lstset{basicstyle=\small\ttfamily}

\begin{document}
%
\title{Untrusted B2B Collaboration using the Blockchain}
%
%
\author{Jonas Beyer \and Philipp Otto \and S\"oren Tietb\"ohl}
%
\authorrunning{J. Beyer et al.}
%
\institute{
	Hasso-Plattner-Institut, Potsdam, Germany\\
	\email{\{jonas.beyer,philipp.otto2,soeren.tietboehl\}@student.hpi.de}}
%
\maketitle % typeset the header of the contribution
%
\begin{abstract}
	Lack of trust between communication partners is one of the major issues companies face when implementing business processes in a cross-organizational setting.
	Blockchain is an emerging technology that enables decentralization and distribution of state without the need for a trusted central instance.
	As a result, it is possible to form consensus in the communication between otherwise untrusting parties.
	In this paper we introduce Armadillo, an open-source prototype implementation for realizing business process choreographies using the Ethereum blockchain.
	We present a user interface for connecting business processes with blockchain calls, as well as an underlying smart contract structure for inter-process communication.

	\keywords{Business Processes \and BPMN \and Choreographies \and Blockchain \and Ethereum \and Smart Contracts}
\end{abstract}
%
%
%
\section{Introduction}

% Establish common ground with reader Worth readers time? Give some results

% Write it once at the start, then rewrite at the end
% use it to guide paper

% Important -> this structure will be expected

% Context (Topic / Terminology)
% Problem & Relevance (Problem - Costs / Current state - Gain)
% Related Work (Existing solutions / Shortcomings)
% Goals / Claims (Contribution, Sketch Results)
% Paper structure (The remainder of this paper is structured as follows ...)

% What is BPMN?
The Business Process Model Notation (BPMN) enables detailed documentation of business processes. This is used to realize complex inter-business processes which involve vast communication structures. One common problem is that within these processes the parties have to trust each other.
% What is Blockchain?

With the increasing spread of Blockchain technology, this problem could be rectified.
A Blockchain is a decentralized information-storage network. Information is stored in blocks, which are chained together via cryptograhic means. This means, that many participants can agree on a common public state of information without trusting each other. This technology is commonly used to realize virtual currencies, also called cryptocurrencies.
Ethereum is one implementation of the Blockchain concept, and it realizes a key feature called smart contracts.
Smart contracts are small programs, which are ran by the Blockchain network. They have very limited processing power, but they enable the execution of code which has a commonly known state.

%What problems are there with BPMN that can be solved with Blockchain?
The problem of needing to trust each other when collaborating in a business process can be addressed by applying the benefits of blockchain technology. The Blockchain be used in several ways to facilitate trusted communication between untrusted parties.

% What approaches exist currently (Caterpillar \cite{lopez2017caterpillar}, Untrusted paper \cite{weber2016untrusted})
Current approaches aim to convert the functionality of traditional BPMN Engines to smart contracts on the Ethereum Blockchain.

Caterpillar~\cite{lopez2017caterpillar} features the implementation of most common BPMN elements. It enables the transformation of BPMN Models to smart contracts, which can be deployed and executed on the Blockchain.

Weber et al.~\cite{weber2016untrusted} realize Orchestrations on the Blockchain.

%What is our general Idea?
We want to expand on the work of Weber et al. and implement true choreographies. In their current approach they are using one central smart contract called a mediator / monitor which manages the Orchestration state.
We will have a set of smart contracts for every party, which will then communicate with each other to realize the choreography.
%What are our results? (briefly)

\section{Preliminary}
In the following section we present concepts and technologies that are related to our concept.

\subsection{Orchestrations and Choreographies}

\subsection{Blockchain}
A blockchain is a distributed ledger that allows users to find a concensus in decentralized applications.
It works by splitting information into blocks that are connected as a linked list.
%TODO proof of work is only one possibility
%TODO explain more in depth?
Each block has to be signed in a way that is mathematically hard to calculate, but easy to verify.
Therefore users can verify if their local blockchain is valid.
If the same block is signed at the same time, a fork of the blockchain can happen, i.e. two versions of the same blockchain exist at the same time.
A concensus is reached by propagating the longest blockchain within the network until it is accepted by all parties of the network.

%TODO reference original blockchain paper
Blockchain technology is used in cryptocurrencies, most notably Bitcoin \cite{nakamoto2008bitcoin}.
The use in cryptocurrency has laid the foundation for a number of decentralized application besides financial ones.
Ethereum \cite{wood2014ethereum} is a cryptocurrency that also builds on blockchain technologies and allows users to execute code in the form of \emph{smart contracts}.
Smart contracts are Turing complete code artifacts, that can be deployed on the blockchain and have an interface that is callable by users.
They can receive and send money, store information locally and emit events on the blockchain ledger.
When calling functions on a smart contract, users have to supply \emph{gas}, a unit that powers smart contract computations.
Contracts deplete gas for each operation and return excess gas back to the user.
This ensures that contracts are not running for an unlimited amount of time and that computations on the blockchain are expensive in order to avoid unnecessary operations being performed on-chain.
%TODO short text on the paper which shows smart contract examples
%TODO short text on solidity

\subsection{Prior Work on Business Processes on the Blockchain}
In \cite{weber2016untrusted}, a first approach of monitoring and coordinating business process interactions across organizations on the blockchain was presented.
Using a smart contract as a central \emph{monitor} or \emph{mediator} of the communication, a form of inter-process orchestration is implemented.
They describe a contract architecture, where a factory contract is responsible for deploying instance contracts for each process instance.
They also introduce the concept of \emph{triggers}, applications that listen to events on the blockchain and trigger external API calls.
In order to achieve BPMN-to-Solidity compilation, they describe translation rules to transform BPMN elements to Solidity code.
%TODO highlight lack of access right explanation and problem of central contract?

%we build on:
%factories \& instances
%registering users to roles
%triggers
%the model they used (originally from Fdhila et al)

%we don\'t:
%do bpmn solidity translation
%use one central contract instance

%summarize Caterpillar
%acknowledge their Work
%display the shortcomings
\cite{lopez2017caterpillar} presents an open-source implementation of an Ethereum-based Business Process Management System.
It implements BPMN-to-Solidity compilation and thereby tracks the state of process executions on the blockchain.
Processes can be started and executed via a user interface, which calls the generated Solidity code in the background.

%describes components and architecture of engine
%automatic bpmn solidity translation
%no choreographies / lanes supported, all tasks / transitions are managed on-chain through process %contract

\section{Solution approach}
We propose a system design, that allows choreographies to be executed publicly on the blockchain.
In the following section, we describe our approach and its architecture.

%basic understanding/ intuition
%-> make orchestration possible

% Decentralized contracts vs. central monitor
% Engine on chain vs. message channel

%use one contuous example

%visualizations !!

\subsection{System overview}
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{fig/system_diagram.eps}
	\caption{An architecture diagram showing the interactions within the system.}
	\label{fig:system_diagram}
\end{figure}

Every organization provides an interface of their public process in an \emph{instance contract}.
Additionally, \emph{factory contracts} manage these instance contracts and \emph{access contracts} are used for rights management.
The contract structure will be described in detail in the following sections.
We assume that all participating organizations use a process engine to execute their private processes.
When a throw event is triggered within a process engine, a \emph{throw event function} is called on an instance contract and the corresponding \emph{catch event function} is called on the instance contract of the organization responsible for catching the event.
Thus, the public processes of all organizations are recorded on the blockchain.

%TODO reference "trigger" from Untrusted paper
Each organization uses a \emph{trigger} that continuously listens to catch events.
If a catch event is observed, this information is relayed to the process engine to handle the event.
The usage of the blockchain to monitor the choreography is encapsulated in the process engine and is therefore hidden from the users.

The interaction of the components can be seen in Figure \ref{fig:system_diagram}.

\subsection{Contract Structure}
To realize the system, we use three kinds of smart contracts.
Firstly, each organization uses one \emph{instance contract} per process instance.
It represents the public process of the organization for the corresponding process.
It is called during the process execution when a catch or throw event is reached in the process instance.
When this happens, it emits an event on the blockchain to document this fact.

Secondly, each organization uses one \emph{factory contract} per process.
It is responsible for creating instance contracts and saving a mapping from instance IDs to the corresponding contracts.

Thirdly, each organization uses \emph{access contracts} to manage which users can trigger events on the instance contracts.
Either, there is on access contract per process or access contracts are shared over multiple processes depending on the use case.

\subsection{Per company setup}
\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/initialization.eps}
	\caption{A sequence diagram describing the initialization process for an organization.}
	\label{fig:initialization}
\end{figure}

%TODO add a step where other factory contracts are set
Each organization needs to perform some setup before they can take part in a process execution.
An access contract and a factory contract for a process need to be deployed it it has not been done yet.
Additionally, the user-to-role and and task-to-role mappings have to be updated, to allow verification of users during the process execution.
A diagram of this process can be seen in Figure \ref{fig:initialization}.

\subsection{Interaction setup}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{fig/instance_creation.eps}
	\caption{A sequence diagram describing the process of creating a new process instance.}
	\label{fig:instance_creation}
\end{figure}

In order to create a new process instance, the organization that initiates the instance by triggering the first throw event has to explicitly create an instance contract by calling the factory contract.
To create an instance contract, the factory contract may need to initialize other instance contracts by calling other factory contracts.
When all partner instance, factory and access contracts are known, the instance contract can be created and its address is returned to the user and an event is emitted to the blockchain.
This process is visualized in Figure \ref{fig:instance_creation}.

The recursive initialization ensures that all instance contracts that are part of the process instance will be created by one function call.
%TODO add emit event in the diagram
%TODO better formulation
The organizations that did not start the instance creation can detect the new process instance by using their trigger to watch the factory contract.

\subsection{Sending messages}
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{fig/event_sending.eps}
	\caption{A sequence diagram describing the process of sending a message to a collaboration partner.}
	\label{fig:event_sending}
\end{figure}

%TODO correctly show that the address is passed instead of using msg.sender
When a throw event is triggered in the process engine of organization $A$, the corresponding \emph{throw event function} is called on the instance contract of the collaboration partner $B$.
In the instance contract of $A$ an authorization is performed by looking up the sender address in the access contract of $A$.
If this check is successful, the \emph{catch event function} is called on the partner instance contract of $B$.
In the instance contract of $B$ there is another authorization against the access contract of $A$.
This ensures that both sides can be confident, that the throw event was triggered by an authorized person who belongs to organization $A$.
If this check was also successful, an event is emitted to the blockchain.
This will be detected by the trigger of $B$ and passed to the process engine.
Thus, a message was sent from $A$ to $B$ via the blockchain and an audit trail was created.
An example can be seen in the sequence diagram in Figure \ref{fig:event_sending}.


\section{Implementation}

Given the architecture, we will now discuss the implementation of the contracts used in the system.
Afterwards, we will shortly describe the tools we built for interacting with the system.

\subsection{Contracts}

In the following, we will formally describe our contract implementations.
The implemented contracts can be found in our repository at \url{https://github.com/p-otto/ProcessesMeetBlockchain2018/tree/master/armadillo/resources}.
% TODO repo ist noch private
% TODO update if repository changes

\subsubsection{Process Contracts}

For taking part in the process collaboration, each company needs to deploy a factory contract that is responsible for creating instance contracts.
To this end, the factory contract source code needs to contain the definition of the company's instance contract.
This closely follows the factory contract pattern used in \cite{weber2016untrusted}, and described as Pattern 14 in \cite{xu2018pattern}.

In our implementation, a company's factory contract also knows the address of the company's access contract for convenience.
Additionally, it stores the addresses of created instances, mapped by a \textit{choreography instance ID}, i.e., an ID that is shared between all choreography participants for each instance of the shared choreography.

To allow interaction between companies via the blockchain, two participants need to exchange the addresses of their factory contracts when there is a direct interaction between them.

A factory contract thus has the resulting interface:
\begin{itemize}
	\item A \texttt{constructor} where the address of the company's access contract is passed
	\item Setter methods for the factory contract addresses of interaction partners
	\item A \texttt{createInstance} function
	\item A \texttt{getAccessAddress} function
	\item A \texttt{isInstance} function, checking if a given address belongs to an instance created by this factory, for a given choreography instance ID % TODO rephrase?
\end{itemize}

Internally, there are a few implementation details worth mentioning.
Regarding storage, private fields are necessary holding the factory contract addresses, the access contract address as well as the instance address mapping.
To avoid communication errors at runtime, it should not be possible to call \texttt{createInstance} before all required factory addresses are set.
Finally, there is one minor implementation difference depending on whether a participant is the \textit{choreography initiator} -- the participant to manually start the choreography instance by sending a request -- or instead is starting its instance as a response to another participant's request: % TODO arrgh bessere formulierung
The initiator needs to generate the choreography instance ID inside of its \texttt{createInstance} function, and pass it to all its interaction partners.
Every other participant needs to have a parameter for the ID in their \texttt{createInstance} function.

Communication between smart contracts happens in the form of function calls.
To allow the factory and instance contracts to call functions on their interaction partner's contracts, the partner's function interface needs to be known, i.e., it needs to be declared in the factory contract source code.
%- the access contract (same for every participant)
%- remote factory contracts (if receiving messages from remote, for verification)
%- remote instance contracts (if sending messages to remote instance)

The instance contract definition is also part of the factory contract source code.
The factory contract creates an instance by calling its constructor and passing all for the inter-process communication required addresses.
Instance contracts provide functions for each sending action, i.e., send tasks or events in the company's process, which can be called by the process engine.
For each receiving action (task or event), a function needs to be present that can be called from other instance contracts.
When company $A$ triggers a sending function on their instance contract, it in turn calls a corresponding receive function on the instance contract of company $B$.

Instance contracts need to store:
\begin{itemize}
	\item The choreography instance ID for verifying incoming messages
	\item The addresses of the factory and access contracts of partners for verifying incoming messages
	\item The addresses of the instance contracts of partners for sending messages
	\item The address of the company's own access contract, for verifying local function calls
	\item The address of the company's own factory contract, for returning any remaining funds upon \texttt{selfdestruct}
\end{itemize}

A few more implementation details are worth noting:
Verification is implemented on sender-side and on receiver side.
Each send function has a guard checking the caller in the company's own access contract.
Each receive function has a guard checking a) that the caller is a contract instance that is part of the choreography instance (via the partner factory contract), and b) checking the account behind the request in the partner's access contract.
Guarding functions against unwanted access was described in pattern 13, Embedded Permission, in \cite{xu2018pattern}.

Having achieved a traceable communication on the blockchain using contract function calls, we still want to access messages in off-chain applications, e.g., triggering process events in a process engine on message receive.
To this end, smart contracts need to implement events that are omitted to the blockchain whenever a receive function is executed.
Blockchain events can then be watched, and reacted upon, by off-chain components.

In our current implementation, the end of a process instance is marked by the instance contract selfdestructing.
At the end of the execution of the last send or receive function in the process, the solidity builtin \texttt{selfdestruct} is called.
By passing the factory contract address, potential remaining funds are transferred to the factory contract.

\subsubsection{Access Contract}

Each company deploys an access contract that holds information about the roles and permissions of the company's employees.
Having permission data encapsuled in a separate access contract follows pattern 12, the Data Contract pattern, from \cite{xu2018pattern}.
It allows decoupling the roles and permissions from the actual contract instances, allowing for a simple modification at runtime.
Access contracts can be deployed per process, or even once per company as a single source of truth for all processes.

To allow the administration of user permissions, access contracts provide the following interface:
\begin{itemize}
	\item \texttt{assignRoleToUser(userAddress, role)}
	\item \texttt{removeRoleFromUser(userAddress, role)}
	\item \texttt{assignTaskToRole(task, role)}
	\item \texttt{removeTaskFromRole(task, role)}
\end{itemize}
The access to these functions should be guarded, allowing only a specific administrator address to call them.

Verifying a users permission to execute a certain task can be achieved by calling \texttt{isAuthorized(userAddress, task)}.
\newline

Given this interface, there are multiple possible implementation approaches for access contracts.
As it was our main focus to develop a running prototype, and not to provide an optimized, production-ready system, we decided on a simple mapping-based implementation:
\begin{lstlisting}[
  caption=Mappings in our access contract implementation,
  language=Solidity
]
pragma solidity ^0.4.23;

contract Access {
    mapping(string => string) taskToRole;
    mapping(string => uint) roleToIndex;
    mapping(address => uint) addressToAccessBitmask;
    ...
}
\end{lstlisting}
The first mapping stores the tasks that can be executed by a specific role (cf. pools and lanes, and their contained tasks, in BPMN diagrams).
The second mapping assigns each role an index in the access bitmask, i.e., if the bit at the given index is set, the user holds the corresponding role.
The third mapping assigns such an access bitmask to each user.

Storing large amounts data on the blockchain is expensive by design.
As the mappings grow in size with each user, role and task that is part of some process in the company, our implementation is probably not suited for real-world application.
Finding optimized, less costly (both in computation cost and storage cost) approaches is part of future work.
One other approach we thought of is based on Pattern 5 of \cite{xu2018pattern} - depicting real world permissions as tokens, and "paying" with these tokens on function call to verify one's role.

\subsection{Tools}

\subsubsection{eth\_admin}

node-js command line tool using vorpal
commands trigger blockchain calls using web3

\subsubsection{armadillo}

\section{Evaluation}
%Gas cost
%Time for one instance
%Setup difficulty
%Security

%Mention problem of giving and removing right to change access rights
%But in the end one instance has to a be superadmin in the contract, if it is leaked there is a problem

% future work: 
% - access contract
% - instantiation
% - automatic generation -> template
\section{Conclusion}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{references}

\end{document}
